if has("autocmd") && exists("+omnifunc")
  autocmd Filetype *
        \if &omnifunc == "" |
        \setlocal omnifunc=syntaxcomplete#Complete |
        \endif
endif

hi Pmenu  guifg=#000000 guibg=#F8F8F8 ctermfg=black ctermbg=Lightgray
hi PmenuSbar  guifg=#8A95A7 guibg=#F8F8F8 gui=NONE ctermfg=darkcyan ctermbg=lightgray cterm=NONE
hi PmenuThumb  guifg=#F8F8F8 guibg=#8A95A7 gui=NONE ctermfg=lightgray ctermbg=darkcyan cterm=NONE

" Some convenient mappings
"inoremap <expr> <Esc>      pumvisible() ? "\<C-e>" : "\<Esc>"
if exists('g:spf13_map_cr_omni_complete')
  inoremap <expr> <CR>     pumvisible() ? "\<C-y>" : "\<CR>"
endif
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <C-d>      pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
inoremap <expr> <C-u>      pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"

" Automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menu,preview,longest

let g:acp_enableatstartup = 1
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#enable_auto_delimiter = 1
let g:neocomplete#max_list = 15
let g:neocomplete#force_overwrite_completefunc = 1

" define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
      \ 'default' : '',
      \ 'vimshell' : $home.'/.vimshell_hist',
      \ 'scheme' : $home.'/.gosh_completions'
      \ }

" define keyword.
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" these two lines conflict with the default digraph mapping of <c-k>
imap <c-k> <plug>(neosnippet_expand_or_jump)
smap <c-k> <plug>(neosnippet_expand_or_jump)

if exists('g:spf13_noninvasive_completion')
  inoremap <cr> <cr>
  " <esc> takes you out of insert mode
  inoremap <expr> <esc>   pumvisible() ? "\<c-y>\<esc>" : "\<esc>"
  " <cr> accepts first, then sends the <cr>
  inoremap <expr> <cr>    pumvisible() ? "\<c-y>\<cr>" : "\<cr>"
  " <down> and <up> cycle like <tab> and <s-tab>
  inoremap <expr> <down>  pumvisible() ? "\<c-n>" : "\<down>"
  inoremap <expr> <up>    pumvisible() ? "\<c-p>" : "\<up>"
  " jump up and down the list
  inoremap <expr> <c-d>   pumvisible() ? "\<pagedown>\<c-p>\<c-n>" : "\<c-d>"
  inoremap <expr> <c-u>   pumvisible() ? "\<pageup>\<c-p>\<c-n>" : "\<c-u>"
endif
" <c-k> complete snippet
" <c-k> jump to next snippet point
imap <silent><expr><c-k> neosnippet#expandable() ?
      \ "\<plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
      \ "\<c-e>" : "\<plug>(neosnippet_expand_or_jump)")
smap <tab> <right><plug>(neosnippet_jump_or_expand)

inoremap <expr><c-g> neocomplete#undo_completion()
inoremap <expr><c-l> neocomplete#complete_common_string()
"inoremap <expr><cr> neocomplete#complete_common_string()

" <cr>: close popup
" <s-cr>: close popup and save indent.
inoremap <expr><s-cr> pumvisible() ? neocomplete#smart_close_popup()."\<cr>" : "\<cr>"

function! clevercr()
  if pumvisible()
    if neosnippet#expandable()
      let exp = "\<plug>(neosnippet_expand)"
      return exp . neocomplete#smart_close_popup()
    else
      return neocomplete#smart_close_popup()
    endif
  else
    return "\<cr>"
  endif
endfunction

" <cr> close popup and save indent or expand snippet
imap <expr> <cr> clevercr()
" <c-h>, <bs>: close popup and delete backword char.
inoremap <expr><bs> neocomplete#smart_close_popup()."\<c-h>"
inoremap <expr><c-y> neocomplete#smart_close_popup()
" <tab>: completion.
inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"
inoremap <expr><s-tab> pumvisible() ? "\<c-p>" : "\<tab>"

" courtesy of matteo cavalleri

function! clevertab()
  if pumvisible()
    return "\<c-n>"
  endif
  let substr = strpart(getline('.'), 0, col('.') - 1)
  let substr = matchstr(substr, '[^ \t]*$')
  if strlen(substr) == 0
    " nothing to match on empty string
    return "\<tab>"
  else
    " existing text matching
    if neosnippet#expandable_or_jumpable()
      return "\<plug>(neosnippet_expand_or_jump)"
    else
      return neocomplete#start_manual_complete()
    endif
  endif
endfunction

imap <expr> <tab> clevertab()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

" enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'

" use honza's snippets.
let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'

" enable neosnippet snipmate compatibility mode
let g:neosnippet#enable_snipmate_compatibility = 1

" for snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" enable neosnippets when using go
let g:go_snippet_engine = "neosnippet"

" disable the neosnippet preview candidate window
" when enabled, there can be too much visual noise
" especially when splits are used.
set completeopt-=preview
